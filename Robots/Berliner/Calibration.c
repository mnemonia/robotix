
/*********************************************************************
	SYSTEM Berliner
	Module for PROCESS Calibration
	Filename: Calibration.c
	generated by CIP Tool(R) Version 4.41.00
		August 17, 2012  4:31:43 am
	activated code options:
		PENDING_ information
		'unsigned char' for 'enum'
		C-code
*********************************************************************/

/* Include Files */

#include "mBerlinerUnit.h"

/* Process Macro Definitions */

#define EXCEPTION return;
#define SELF status_Calibration.write_access_
#define STATUS status_Calibration.read_access_
#define TIME time_mBerlinerUnit

/* Process Definitions */

/* MODES */
#define normal 1

/* STATES */
#define GoBackward 1
#define GoForward 2
#define GoLeft 3
#define GoRight 4
#define On 5
#define Stop 6


/* INPULSES */
#define TIMEUP_ 1


/* OUTPULSES */

#define O3_BWD 10
#define O3_FWD 8
#define O3_GoLeft 11
#define O3_GoRight 12
#define O3_STOP 9
#define O4_Backward 4
#define O4_BackwardLeft 5
#define O4_BackwardRight 6
#define O4_Forward 3
#define O4_ForwardLeft 1
#define O4_ForwardRight 2
#define O4_Stop 7

/* External Declarations */

extern unsigned long time_mBerlinerUnit;
extern struct tTMQE_mBerlinerUnit *tuhead_mBerlinerUnit, *tutail_mBerlinerUnit;
extern union tCHNOUT_mBerlinerUnit CHNOUT_mBerlinerUnit;
extern struct tTIMING_mBerlinerUnit TIMING_mBerlinerUnit;

void fUPDATE_Locomotion (void);
int fPULSE_Drive (unsigned char name_);
void fSETTIM_mBerlinerUnit (unsigned long *delay_, struct tTMEL_mBerlinerUnit *timer_, struct tTMQE_mBerlinerUnit *timeup_);
void fSTOPTIM_mBerlinerUnit (struct tTMEL_mBerlinerUnit *timer_, struct tTMQE_mBerlinerUnit *timeup_);

/* Global Declarations */

static unsigned long delay_;
struct tPRINST_Calibration IO_Calibration;
union tSTATUS_Calibration status_Calibration;

/* Function Prototypes */

void fICHAN_CalibrationChannel (unsigned char name_);
void fINIT_Calibration (void);

/* Input Channel Functions */

void fICHAN_CalibrationChannel (unsigned char name_)
{
	switch (name_)
	{
		/***  MESSAGE CALIBRATE of INPORT CalibarationEvents  ***/
	case C1_CALIBRATE:
		switch (status_Calibration.read_access_.STATE)
		{
		case 5:  /* STATE On */
			{
				delay_ =  50;	/***  DELAY DEFAULT  ***/
				status_Calibration.write_access_.STATE = 2;  /* STATE GoForward */
				fSETTIM_mBerlinerUnit (&delay_, 
					&IO_Calibration.timer_, 
					&IO_Calibration.timeup_);
				fPULSE_Drive (O3_FWD);
			}
			break;
		default: 
			return;
		}
		break;
	default: 
		return;
	}
	fUPDATE_Locomotion ();
	return;
}

#undef EXCEPTION

/* Timer Functions */

static void fTICK_Calibration (void)
{
	if (IO_Calibration.timer_.set_ && 
		IO_Calibration.timer_.end_ == time_mBerlinerUnit)
	{
		IO_Calibration.timer_.set_ = FALSE;
		--TIMING_mBerlinerUnit.set_;
		if (tuhead_mBerlinerUnit != &IO_Calibration.timeup_ && 
			!IO_Calibration.timeup_.preced_ && 
			!IO_Calibration.timeup_.next_)
		{
			if (! tuhead_mBerlinerUnit)
				tuhead_mBerlinerUnit = tutail_mBerlinerUnit = &IO_Calibration.timeup_;
			else 
			{
				tutail_mBerlinerUnit->next_ = &IO_Calibration.timeup_;
				IO_Calibration.timeup_.preced_ = tutail_mBerlinerUnit;
				tutail_mBerlinerUnit = &IO_Calibration.timeup_;
			}
		}
	}
}

static void fTUHNDL_Calibration (void)
{
	struct tTMQE_mBerlinerUnit *element_ = tuhead_mBerlinerUnit;
	if (tuhead_mBerlinerUnit == tutail_mBerlinerUnit)
		tuhead_mBerlinerUnit = tutail_mBerlinerUnit = 0;
	else 
	{
		tuhead_mBerlinerUnit = element_->next_;
		element_->next_ = 0;
		tuhead_mBerlinerUnit->preced_ = 0;
	}
	switch (status_Calibration.read_access_.STATE)
	{
	case 1:  /* STATE GoBackward */
		{
			delay_ =  50;	/***  DELAY DEFAULT  ***/
			status_Calibration.write_access_.STATE = 3;  /* STATE GoLeft */
			fSETTIM_mBerlinerUnit (&delay_, 
				&IO_Calibration.timer_, 
				&IO_Calibration.timeup_);
			fPULSE_Drive (O3_GoLeft);
		}
		break;
	case 2:  /* STATE GoForward */
		{
			delay_ =  50;	/***  DELAY DEFAULT  ***/
			status_Calibration.write_access_.STATE = 6;  /* STATE Stop */
			fSETTIM_mBerlinerUnit (&delay_, 
				&IO_Calibration.timer_, 
				&IO_Calibration.timeup_);
			fPULSE_Drive (O3_STOP);
		}
		break;
	case 3:  /* STATE GoLeft */
		{
			delay_ =  50;	/***  DELAY DEFAULT  ***/
			status_Calibration.write_access_.STATE = 4;  /* STATE GoRight */
			fSETTIM_mBerlinerUnit (&delay_, 
				&IO_Calibration.timer_, 
				&IO_Calibration.timeup_);
			fPULSE_Drive (O3_GoRight);
		}
		break;
	case 4:  /* STATE GoRight */
		status_Calibration.write_access_.STATE = 5;  /* STATE On */
		fPULSE_Drive (O3_STOP);
		break;
	case 6:  /* STATE Stop */
		{
			delay_ =  50;	/***  DELAY DEFAULT  ***/
			status_Calibration.write_access_.STATE = 1;  /* STATE GoBackward */
			fSETTIM_mBerlinerUnit (&delay_, 
				&IO_Calibration.timer_, 
				&IO_Calibration.timeup_);
			fPULSE_Drive (O3_BWD);
		}
		break;
	default: 
		break;
	}
	fUPDATE_Locomotion ();
}

/* Process Initialization Function */

void fINIT_Calibration (void)
{
	status_Calibration.write_access_.STATE = 5;  /* STATE On */
	IO_Calibration.timer_.set_ = FALSE;
	IO_Calibration.timeup_.preced_ = 0;
	IO_Calibration.timeup_.next_ = 0;
	IO_Calibration.timeup_.proctype_ = 0;
	TIMING_mBerlinerUnit.tkhndl_ = fTICK_Calibration;
	TIMING_mBerlinerUnit.tuhndl_ = fTUHNDL_Calibration;
}

/*********************************************************************
	End of Module for PROCESS Calibration
*********************************************************************/
