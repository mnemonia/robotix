
/*********************************************************************
	SYSTEM Chaot
	IMPLEMENTATION ChaotImpl
	Module for CIP MACHINE mChaotUnit
	Filename: mChaotUnit.c
	generated by CIP Tool(R) Version 4.41.00
		May 1, 2012  3:31:51 am
	activated code options:
		PENDING_ information
		'unsigned char' for 'enum'
		C-code
*********************************************************************/

/* Include Files */

#include "mChaotUnit.h"

/* External Declarations */

void fICHAN_ChaoticEvents (unsigned char name_);
void fICHAN_MeasureEvents (unsigned char name_, 
	union tDATA_MeasureEvents *data_);
void fICHAN_Start (unsigned char name_);
void fINIT_Chaotic (void);
void fINIT_Controller (void);
void fINIT_Indicator (void);
void fINIT_Measure (void);
void fINIT_Shaker (void);

/* Global Declarations */

unsigned long time_mChaotUnit = 0;
union tCHNOUT_mChaotUnit CHNOUT_mChaotUnit;
struct tTIMING_mChaotUnit TIMING_mChaotUnit[2];
struct tTMQE_mChaotUnit *tuhead_mChaotUnit, *tutail_mChaotUnit;

/* Function Prototypes */

void fSETTIM_mChaotUnit (unsigned long *delay_, struct tTMEL_mChaotUnit *timer_, struct tTMQE_mChaotUnit *timeup_);
void fSTOPTIM_mChaotUnit (struct tTMEL_mChaotUnit *timer_, struct tTMQE_mChaotUnit *timeup_);
void fSTEP_mChaotUnit(void);
void fCHAIN_mChaotUnit(void);
void fTIMEUP_mChaotUnit(void);
void fREAD_mChaotUnit(void);
void fUPDATE_Robot (void);

/* AUTO_ Handler Function */

static void fAUTOHDL_mChaotUnit(void)
{
		/* dummy function handling no AUTO_ */
}

/* Timer Functions */

static void fTICK_mChaotUnit(void)
{
	int i_;
	time_mChaotUnit ++;
	for (i_ = 0; i_ < 2; i_ ++)
		if (TIMING_mChaotUnit[i_].set_)
			TIMING_mChaotUnit[i_].tkhndl_ ();
	TRG_.PENDING_.TIMEUP_ = tuhead_mChaotUnit != 0;
	TRG_.PENDING_.ANY_ = TRG_.PENDING_.ANY_ || TRG_.PENDING_.TIMEUP_;
}

void fSETTIM_mChaotUnit (unsigned long *delay_, struct tTMEL_mChaotUnit *timer_, struct tTMQE_mChaotUnit *timeup_)
{
	if (*delay_ > 0)
	{
		if (! timer_->set_)
			++TIMING_mChaotUnit[timeup_->proctype_].set_;
		timer_->set_ = TRUE;
		timer_->end_ = time_mChaotUnit + *delay_;
		if (tuhead_mChaotUnit == timeup_)
			tuhead_mChaotUnit = tuhead_mChaotUnit->next_;
		if (timeup_->preced_)
			timeup_->preced_->next_ = timeup_->next_;
		if (timeup_->next_)
			timeup_->next_->preced_ = timeup_->preced_;
		if (tutail_mChaotUnit == timeup_)
			tutail_mChaotUnit = timeup_->preced_;
		timeup_->preced_ = 0;
		timeup_->next_ = 0;
	}
	else 
	{
		if (timer_->set_)
			--TIMING_mChaotUnit [timeup_->proctype_].set_;
		timer_->set_ = FALSE;
		if (tuhead_mChaotUnit != timeup_ && ! timeup_->preced_ && ! timeup_->next_)
		{
			if (! tuhead_mChaotUnit)
				tuhead_mChaotUnit = tutail_mChaotUnit = timeup_;
			else 
			{
				tutail_mChaotUnit->next_ = timeup_;
				timeup_->preced_ = tutail_mChaotUnit;
				tutail_mChaotUnit = timeup_;
			}
		}
	}
}

void fSTOPTIM_mChaotUnit (struct tTMEL_mChaotUnit *timer_, struct tTMQE_mChaotUnit *timeup_)
{
	if (timer_->set_)
		--TIMING_mChaotUnit [timeup_->proctype_].set_;
	timer_->set_ = FALSE;
	if (tuhead_mChaotUnit == timeup_)
		tuhead_mChaotUnit = tuhead_mChaotUnit->next_;
	if (timeup_->preced_)
		timeup_->preced_->next_ = timeup_->next_;
	if (timeup_->next_)
		timeup_->next_->preced_ = timeup_->preced_;
	if (tutail_mChaotUnit == timeup_)
		tutail_mChaotUnit = timeup_->preced_;
	timeup_->preced_ = 0;
	timeup_->next_ = 0;
}

/* Control Functions */

	/* Step Function for CIP Machine */

void fSTEP_mChaotUnit(void)
{
	if (tuhead_mChaotUnit != 0)
		TIMING_mChaotUnit[tuhead_mChaotUnit->proctype_].tuhndl_ ();
	return;
}

	/* Chain Function for CIP Machine */

void fCHAIN_mChaotUnit(void)
{
	return;
}

	/* Timeup Function for CIP Machine */

void fTIMEUP_mChaotUnit(void)
{
	if (tuhead_mChaotUnit != 0)
		TIMING_mChaotUnit [tuhead_mChaotUnit->proctype_].tuhndl_ ();
	return;
}

	/* Read Function for CIP Machine */

void fREAD_mChaotUnit(void)
{
	return;
}

/* Update Functions */

void fUPDATE_Robot (void)
{
	TRG_.PENDING_.TIMEUP_ = tuhead_mChaotUnit != 0;
	TRG_.PENDING_.ANY_ = 
		TRG_.PENDING_.TIMEUP_;
}

/* Initialization Function */

int fINIT_(void)
{
	tuhead_mChaotUnit = tutail_mChaotUnit = 0;
	TRG_.TICK_ = fTICK_mChaotUnit;
	TRG_.CHAIN_ = fCHAIN_mChaotUnit;
	TRG_.TIMEUP_ = fTIMEUP_mChaotUnit;
	TRG_.STEP_ = fSTEP_mChaotUnit;
	TRG_.READ_ = fREAD_mChaotUnit;
	TRG_.AUTO_ = fAUTOHDL_mChaotUnit;
	TRG_.PENDING_.ANY_ = 0;
	TRG_.PENDING_.CHAIN_ = 0;
	TRG_.PENDING_.TIMEUP_ = 0;
	TRG_.PENDING_.READ_ = 0;
	TRG_.PENDING_.AUTO_ = 0;
	IN_.ChaoticEvents = fICHAN_ChaoticEvents;
	IN_.MeasureEvents = fICHAN_MeasureEvents;
	IN_.Start = fICHAN_Start;
	iCHAN_();
	if (!OUT_.MeasureActions)
		return 0;
	if (!OUT_.IndicatorActions)
		return 0;
	if (!OUT_.ShakerActions)
		return 0;
	if (!OUT_.ControllerActions)
		return 0;
	if (!OUT_.ChaoticActions)
		return 0;
	fINIT_Chaotic ();
	fINIT_Controller ();
	fINIT_Indicator ();
	fINIT_Measure ();
	fINIT_Shaker ();
	return 1;
}

/*********************************************************************
	End of Module for CIP MACHINE mChaotUnit
*********************************************************************/
