
/*********************************************************************
	SYSTEM Starbot
	Module for PROCESS Track
	Filename: Track.c
	generated by CIP Tool(R) Version 4.41.00
		June 12, 2012  12:31:41 am
	activated code options:
		PENDING_ information
		'unsigned char' for 'enum'
		C-code
*********************************************************************/

/* Include Files */

#include "mStarbotUnit.h"

/* Process Macro Definitions */

#define EXCEPTION return;
#define SELF status_Track.write_access_
#define STATUS status_Track.read_access_
#define TIME time_mStarbotUnit

/* Process Definitions */

/* MODES */
#define normal 1

/* STATES */
#define Idle 1
#define Tracking 2


/* INPULSES */
#define TIMEUP_ 1
#define IP_TRACK 2


/* OUTPULSES */

#define O4_ATTRACTED_PLAYER 3
#define O1_ATTRACKING_PLAYER 2
#define O1_RUNNING 1

/* External Declarations */

extern unsigned long time_mStarbotUnit;
extern struct tTMQE_mStarbotUnit *tuhead_mStarbotUnit, *tutail_mStarbotUnit;
extern union tCHNOUT_mStarbotUnit CHNOUT_mStarbotUnit;
extern struct tTIMING_mStarbotUnit TIMING_mStarbotUnit[3];

void fUPDATE_Behavior (void);
void fSETTIM_mStarbotUnit (unsigned long *delay_, struct tTMEL_mStarbotUnit *timer_, struct tTMQE_mStarbotUnit *timeup_);
void fSTOPTIM_mStarbotUnit (struct tTMEL_mStarbotUnit *timer_, struct tTMQE_mStarbotUnit *timeup_);

/* Global Declarations */

static unsigned long delay_;
struct tPRINST_Track IO_Track;
union tSTATUS_Track status_Track;

/* Function Prototypes */

void fICHAN_TrackInChannel (unsigned char name_);
int fPULSE_Track (unsigned char name_);
void fINIT_Track (void);

/* Input Channel Functions */

void fICHAN_TrackInChannel (unsigned char name_)
{
	switch (name_)
	{
		/***  MESSAGE CENTER of INPORT TrackEvent  ***/
	case C7_CENTER:
		switch (status_Track.read_access_.STATE)
		{
		case 2:  /* STATE Tracking */
			{
				delay_ =  20;	/***  DELAY TrackingTimer  ***/
				status_Track.write_access_.STATE = 2;  /* STATE Tracking */
				CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_ = C6_TRACK_CENTER;
				OUT_.TrackOutChannel (CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_);
				fSETTIM_mStarbotUnit (&delay_, 
					&IO_Track.timer_, 
					&IO_Track.timeup_);
			}
			break;
		default: 
			return;
		}
		break;
		/***  MESSAGE LEFT of INPORT TrackEvent  ***/
	case C7_LEFT:
		switch (status_Track.read_access_.STATE)
		{
		case 2:  /* STATE Tracking */
			{
				delay_ =  20;	/***  DELAY TrackingTimer  ***/
				status_Track.write_access_.STATE = 2;  /* STATE Tracking */
				CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_ = C6_TRACK_LEFT;
				OUT_.TrackOutChannel (CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_);
				fSETTIM_mStarbotUnit (&delay_, 
					&IO_Track.timer_, 
					&IO_Track.timeup_);
			}
			break;
		default: 
			return;
		}
		break;
		/***  MESSAGE RIGHT of INPORT TrackEvent  ***/
	case C7_RIGHT:
		switch (status_Track.read_access_.STATE)
		{
		case 2:  /* STATE Tracking */
			{
				delay_ =  20;	/***  DELAY TrackingTimer  ***/
				status_Track.write_access_.STATE = 2;  /* STATE Tracking */
				CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_ = C6_TRACK_RIGHT;
				OUT_.TrackOutChannel (CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_);
				fSETTIM_mStarbotUnit (&delay_, 
					&IO_Track.timer_, 
					&IO_Track.timeup_);
			}
			break;
		default: 
			return;
		}
		break;
	default: 
		return;
	}
	fUPDATE_Behavior ();
	return;
}

#undef EXCEPTION

int fPULSE_Track (unsigned char name_)
{
	switch (name_)
	{
		/***  INPULSE TRACK  ***/
	case O1_RUNNING:		/***  PULSE CAST from PROCESS Start  ***/
		switch (status_Track.read_access_.STATE)
		{
		case 1:  /* STATE Idle */
			{
				delay_ =  20;	/***  DELAY TrackingTimer  ***/
				status_Track.write_access_.STATE = 2;  /* STATE Tracking */
				CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_ = C6_TRACK_PLAYER;
				OUT_.TrackOutChannel (CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_);
				fSETTIM_mStarbotUnit (&delay_, 
					&IO_Track.timer_, 
					&IO_Track.timeup_);
			}
			break;
		default: 
			break;
		}
		break;
	default: 
		return 0;
	}
	return 1;
}

/* Timer Functions */

static void fTICK_Track (void)
{
	if (IO_Track.timer_.set_ && 
		IO_Track.timer_.end_ == time_mStarbotUnit)
	{
		IO_Track.timer_.set_ = FALSE;
		--TIMING_mStarbotUnit[2].set_;
		if (tuhead_mStarbotUnit != &IO_Track.timeup_ && 
			!IO_Track.timeup_.preced_ && 
			!IO_Track.timeup_.next_)
		{
			if (! tuhead_mStarbotUnit)
				tuhead_mStarbotUnit = tutail_mStarbotUnit = &IO_Track.timeup_;
			else 
			{
				tutail_mStarbotUnit->next_ = &IO_Track.timeup_;
				IO_Track.timeup_.preced_ = tutail_mStarbotUnit;
				tutail_mStarbotUnit = &IO_Track.timeup_;
			}
		}
	}
}

static void fTUHNDL_Track (void)
{
	struct tTMQE_mStarbotUnit *element_ = tuhead_mStarbotUnit;
	if (tuhead_mStarbotUnit == tutail_mStarbotUnit)
		tuhead_mStarbotUnit = tutail_mStarbotUnit = 0;
	else 
	{
		tuhead_mStarbotUnit = element_->next_;
		element_->next_ = 0;
		tuhead_mStarbotUnit->preced_ = 0;
	}
	switch (status_Track.read_access_.STATE)
	{
	case 2:  /* STATE Tracking */
		{
			delay_ =  20;	/***  DELAY TrackingTimer  ***/
			status_Track.write_access_.STATE = 2;  /* STATE Tracking */
			CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_ = C6_TRACK_PLAYER;
			OUT_.TrackOutChannel (CHNOUT_mStarbotUnit.CHAN_TrackOutChannel.name_);
			fSETTIM_mStarbotUnit (&delay_, 
				&IO_Track.timer_, 
				&IO_Track.timeup_);
		}
		break;
	default: 
		break;
	}
	fUPDATE_Behavior ();
}

/* Process Initialization Function */

void fINIT_Track (void)
{
	status_Track.write_access_.STATE = 1;  /* STATE Idle */
	IO_Track.timer_.set_ = FALSE;
	IO_Track.timeup_.preced_ = 0;
	IO_Track.timeup_.next_ = 0;
	IO_Track.timeup_.proctype_ = 2;
	TIMING_mStarbotUnit[2].tkhndl_ = fTICK_Track;
	TIMING_mStarbotUnit[2].tuhndl_ = fTUHNDL_Track;
}

/*********************************************************************
	End of Module for PROCESS Track
*********************************************************************/
