
/*********************************************************************
	SYSTEM Workspace
	Module for PROCESS LightDimmer
	Filename: LightDimmer.c
	generated by CIP Tool(R) Version 4.41.00
		February 14, 2015  2:52:48 am
	activated code options:
		PENDING_ information
		'unsigned char' for 'enum'
		C-code
*********************************************************************/

/* Include Files */

#include "mTheUnit.h"

/* Process Macro Definitions */

#define EXCEPTION return;
#define SELF status_LightDimmer.write_access_
#define STATUS status_LightDimmer.read_access_
#define TIME time_mTheUnit

/* Process Definitions */

/* MODES */
#define normal 1

/* STATES */
#define Fade_In 1
#define Fade_Out 2
#define Off 3
#define On 4


/* INPULSES */
#define IP_FADE_IN 1
#define IP_FADE_OUT 2
#define TIMEUP_ 3


/* OUTPULSES */

#define O5_OFF 8
#define O5_ON 7
#define O3_OFF 2
#define O3_ON 1
#define O1_IS_OFF 6
#define O1_IS_ON 5
#define O2_OFF 4
#define O2_ON 3

/* External Declarations */

extern unsigned long time_mTheUnit;
extern struct tTMQE_mTheUnit *tuhead_mTheUnit, *tutail_mTheUnit;
extern union tCHNOUT_mTheUnit CHNOUT_mTheUnit;
extern struct tTIMING_mTheUnit TIMING_mTheUnit[2];

void fUPDATE_Controller (void);
int fPULSE_LightSwitch (unsigned char name_);
void fSETTIM_mTheUnit (unsigned long *delay_, struct tTMEL_mTheUnit *timer_, struct tTMQE_mTheUnit *timeup_);
void fSTOPTIM_mTheUnit (struct tTMEL_mTheUnit *timer_, struct tTMQE_mTheUnit *timeup_);

/* Global Declarations */

static unsigned long delay_;
struct tPRINST_LightDimmer IO_LightDimmer;
union tSTATUS_LightDimmer status_LightDimmer;

/* Function Prototypes */

void fICHAN_LightSwitchDimReply (unsigned char name_);
int fPULSE_LightDimmer (unsigned char name_);
void fINIT_LightDimmer (void);

/* Input Channel Functions */

void fICHAN_LightSwitchDimReply (unsigned char name_)
{
	switch (name_)
	{
		/***  MESSAGE IS_OFF of INPORT LightDimmerEvent  ***/
	case C3_IS_OFF:
		switch (status_LightDimmer.read_access_.STATE)
		{
		case 2:  /* STATE Fade_Out */
			status_LightDimmer.write_access_.STATE = 3;  /* STATE Off */
			fSTOPTIM_mTheUnit (&IO_LightDimmer.timer_, 
				&IO_LightDimmer.timeup_);
			fPULSE_LightSwitch (O1_IS_OFF);
			break;
		default: 
			return;
		}
		break;
		/***  MESSAGE IS_ON of INPORT LightDimmerEvent  ***/
	case C3_IS_ON:
		switch (status_LightDimmer.read_access_.STATE)
		{
		case 1:  /* STATE Fade_In */
			status_LightDimmer.write_access_.STATE = 4;  /* STATE On */
			fSTOPTIM_mTheUnit (&IO_LightDimmer.timer_, 
				&IO_LightDimmer.timeup_);
			fPULSE_LightSwitch (O1_IS_ON);
			break;
		default: 
			return;
		}
		break;
	default: 
		return;
	}
	fUPDATE_Controller ();
	return;
}

#undef EXCEPTION

int fPULSE_LightDimmer (unsigned char name_)
{
	switch (name_)
	{
		/***  INPULSE FADE_IN  ***/
	case O3_ON:		/***  PULSE CAST from PROCESS Light  ***/
		switch (status_LightDimmer.read_access_.STATE)
		{
		case 3:  /* STATE Off */
			{
				delay_ =  3;	/***  DELAY LIGHT_FADE_IN_DELAY  ***/
				status_LightDimmer.write_access_.STATE = 1;  /* STATE Fade_In */
				CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_ = C1_PLUS;
				OUT_.LightSwitchAction (CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_);
				fSETTIM_mTheUnit (&delay_, 
					&IO_LightDimmer.timer_, 
					&IO_LightDimmer.timeup_);
			}
			break;
		default: 
			break;
		}
		break;
		/***  INPULSE FADE_OUT  ***/
	case O3_OFF:		/***  PULSE CAST from PROCESS Light  ***/
		switch (status_LightDimmer.read_access_.STATE)
		{
		case 4:  /* STATE On */
			{
				delay_ =  5;	/***  DELAY LIGHT_FADE_OUT_DELAY  ***/
				status_LightDimmer.write_access_.STATE = 2;  /* STATE Fade_Out */
				CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_ = C1_MINUS;
				OUT_.LightSwitchAction (CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_);
				fSETTIM_mTheUnit (&delay_, 
					&IO_LightDimmer.timer_, 
					&IO_LightDimmer.timeup_);
			}
			break;
		default: 
			break;
		}
		break;
	default: 
		return 0;
	}
	return 1;
}

/* Timer Functions */

static void fTICK_LightDimmer (void)
{
	if (IO_LightDimmer.timer_.set_ && 
		IO_LightDimmer.timer_.end_ == time_mTheUnit)
	{
		IO_LightDimmer.timer_.set_ = FALSE;
		--TIMING_mTheUnit[1].set_;
		if (tuhead_mTheUnit != &IO_LightDimmer.timeup_ && 
			!IO_LightDimmer.timeup_.preced_ && 
			!IO_LightDimmer.timeup_.next_)
		{
			if (! tuhead_mTheUnit)
				tuhead_mTheUnit = tutail_mTheUnit = &IO_LightDimmer.timeup_;
			else 
			{
				tutail_mTheUnit->next_ = &IO_LightDimmer.timeup_;
				IO_LightDimmer.timeup_.preced_ = tutail_mTheUnit;
				tutail_mTheUnit = &IO_LightDimmer.timeup_;
			}
		}
	}
}

static void fTUHNDL_LightDimmer (void)
{
	struct tTMQE_mTheUnit *element_ = tuhead_mTheUnit;
	if (tuhead_mTheUnit == tutail_mTheUnit)
		tuhead_mTheUnit = tutail_mTheUnit = 0;
	else 
	{
		tuhead_mTheUnit = element_->next_;
		element_->next_ = 0;
		tuhead_mTheUnit->preced_ = 0;
	}
	switch (status_LightDimmer.read_access_.STATE)
	{
	case 1:  /* STATE Fade_In */
		{
			delay_ =  3;	/***  DELAY LIGHT_FADE_IN_DELAY  ***/
			status_LightDimmer.write_access_.STATE = 1;  /* STATE Fade_In */
			CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_ = C1_PLUS;
			OUT_.LightSwitchAction (CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_);
			fSETTIM_mTheUnit (&delay_, 
				&IO_LightDimmer.timer_, 
				&IO_LightDimmer.timeup_);
		}
		break;
	case 2:  /* STATE Fade_Out */
		{
			delay_ =  5;	/***  DELAY LIGHT_FADE_OUT_DELAY  ***/
			status_LightDimmer.write_access_.STATE = 2;  /* STATE Fade_Out */
			CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_ = C1_MINUS;
			OUT_.LightSwitchAction (CHNOUT_mTheUnit.CHAN_LightSwitchAction.name_);
			fSETTIM_mTheUnit (&delay_, 
				&IO_LightDimmer.timer_, 
				&IO_LightDimmer.timeup_);
		}
		break;
	default: 
		break;
	}
	fUPDATE_Controller ();
}

/* Process Initialization Function */

void fINIT_LightDimmer (void)
{
	status_LightDimmer.write_access_.STATE = 3;  /* STATE Off */
	IO_LightDimmer.timer_.set_ = FALSE;
	IO_LightDimmer.timeup_.preced_ = 0;
	IO_LightDimmer.timeup_.next_ = 0;
	IO_LightDimmer.timeup_.proctype_ = 1;
	TIMING_mTheUnit[1].tkhndl_ = fTICK_LightDimmer;
	TIMING_mTheUnit[1].tuhndl_ = fTUHNDL_LightDimmer;
}

/*********************************************************************
	End of Module for PROCESS LightDimmer
*********************************************************************/
